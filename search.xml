<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>進階資料結構 for NCKU-ICPC Week 9</title>
      <link href="/code/ncku-icpc-2020-week9-dlc/"/>
      <url>/code/ncku-icpc-2020-week9-dlc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>有些內容筆者本來想要放在這週的授課內容中<br>不過一來是筆者的期中快要爆炸，沒有空做簡報<br>另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）<br>因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格</p><a id="more"></a><h2 id="線段樹-Extra"><a class="header-anchor" href="#線段樹-Extra"></a>線段樹 Extra</h2><h3 id="持久化"><a class="header-anchor" href="#持久化"></a>持久化</h3><h4 id="老樣子開始前先看個題目"><a class="header-anchor" href="#老樣子開始前先看個題目"></a>老樣子開始前先看個題目</h4><blockquote><p>給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下</p><ol><li>修改其中一個元素的值</li><li>查詢查詢區間 $[l, r]$ 內的最大值</li><li>回復到第 k 次修改後的狀態</li></ol><p>$N, M \le 10 ^ 5, k \le$ 當前修改次數, $0 \le l, r \lt N$</p></blockquote><p>1, 2 都還是基本的線段樹，那麼 3 呢</p><p>感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去</p><p>所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體…先 MLE 了<br>再看一下時間複雜度：$O(M(N + \log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\log N)$，最糟糕要執行 $M$ 次）<br>從各種方面來看感覺都不會過</p><h4 id="先觀察一下"><a class="header-anchor" href="#先觀察一下"></a>先觀察一下</h4><p>對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已<br>也就是說 <strong>其他節點沿用舊的資料也沒關係</strong></p><img src="/code/ncku-icpc-2020-week9-dlc/segmentTree.png" title="持久化線段樹示意圖"><p>但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事<br>看來我們需要換個想法</p><h4 id="Hmmm，指標？"><a class="header-anchor" href="#Hmmm，指標？"></a>Hmmm，指標？</h4><p>沒錯，就是指標<br>只要紀錄記憶體位置就好，不用把整個 node 都複製過去</p><p>所以現在線段樹要改成指標版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    node ( <span class="keyword">int</span> _val ): l ( <span class="literal">nullptr</span> ), r ( <span class="literal">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">        value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( l )</span><br><span class="line">            value = max ( value, l -&gt; value );</span><br><span class="line">        <span class="keyword">if</span> ( r )</span><br><span class="line">            value = max ( value, r -&gt; value );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *seg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class="line">    o = <span class="keyword">new</span> node ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build ( l, mid, o -&gt; l );</span><br><span class="line">    build ( mid + <span class="number">1</span>, r, o -&gt; r );</span><br><span class="line"></span><br><span class="line">    o -&gt; up();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        o -&gt; value = value;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( index &lt;= mid )</span><br><span class="line">            update ( l, mid, index, value, o -&gt; l );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update ( mid + <span class="number">1</span>, r, index, value, o -&gt; r );</span><br><span class="line"></span><br><span class="line">        o -&gt; up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, node *o )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class="line">        <span class="keyword">return</span> o -&gt; value;</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, o -&gt; r );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class="number">1</span>, nowR, o -&gt; r ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, l, r, in, type;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    build ( <span class="number">1</span>, n, seg );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">        update ( <span class="number">1</span>, n, i, in, seg );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type 1: 單點修改</span></span><br><span class="line">    <span class="comment">// type 2: 區間查詢最大值</span></span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class="line">            update ( <span class="number">1</span>, n, l, in, seg );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( type == <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query ( l, r, <span class="number">1</span>, n, seg ) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化-v2"><a class="header-anchor" href="#持久化-v2"></a>持久化</h4><p>因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來<br>並且把左右子結點的指標，指向原本左右子結點的位置<br>接著就是如前面講的，直接上持久化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    node ( <span class="keyword">int</span> _val ): l ( <span class="literal">nullptr</span> ), r ( <span class="literal">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 新增一個建構子，可以直接複製原本的 l, r</span></span><br><span class="line">    node ( node *o ): l ( o -&gt; l ), r ( o -&gt; r ), value ( o -&gt; value ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">        value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( l )</span><br><span class="line">            value = max ( value, l -&gt; value );</span><br><span class="line">        <span class="keyword">if</span> ( r )</span><br><span class="line">            value = max ( value, r -&gt; value );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *seg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class="line">    o = <span class="keyword">new</span> node ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build ( l, mid, o -&gt; l );</span><br><span class="line">    build ( mid + <span class="number">1</span>, r, o -&gt; r );</span><br><span class="line"></span><br><span class="line">    o -&gt; up();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class="line">    <span class="comment">// 把需要修改的節點在修改前先開一個新位置出來</span></span><br><span class="line">    o = <span class="keyword">new</span> node ( o );</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        o -&gt; value = value;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( index &lt;= mid )</span><br><span class="line">            update ( l, mid, index, value, o -&gt; l );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update ( mid + <span class="number">1</span>, r, index, value, o -&gt; r );</span><br><span class="line"></span><br><span class="line">        o -&gt; up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, node *o )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class="line">        <span class="keyword">return</span> o -&gt; value;</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, o -&gt; r );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class="number">1</span>, nowR, o -&gt; r ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, l, r, in, type;</span><br><span class="line">    <span class="comment">// 紀錄版本用的 vector</span></span><br><span class="line">    <span class="built_in">vector</span> &lt; node* &gt; version;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    build ( <span class="number">1</span>, n, seg );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">        update ( <span class="number">1</span>, n, i, in, seg );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 記錄初始版本</span></span><br><span class="line">    version.push_back ( seg );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type 1: 單點修改</span></span><br><span class="line">    <span class="comment">// type 2: 區間查詢最大值</span></span><br><span class="line">    <span class="comment">// type 3: 回朔到版本 k</span></span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class="line">            update ( <span class="number">1</span>, n, l, in, seg );</span><br><span class="line">            <span class="comment">// 修改完紀錄版本</span></span><br><span class="line">            version.push_back ( seg );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( type == <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query ( l, r, <span class="number">1</span>, n, seg ) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 回朔到版本 k</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">            seg = version[in];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="有修改過的地方"><a class="header-anchor" href="#有修改過的地方"></a>有修改過的地方</h5><table><thead><tr><th>line</th><th>修改內容</th></tr></thead><tbody><tr><td>12</td><td>新增一個建構子，可以直接複製原本的 l, r</td></tr><tr><td>36</td><td>在對節點修改前先開一個新的位置</td></tr><tr><td>69</td><td>記錄用的 vector</td></tr><tr><td>77, 88</td><td>修改完成後，記錄當前版本內容</td></tr><tr><td>94</td><td>新增一個操作，可回朔到版本 k</td></tr></tbody></table><h3 id="非簡單操作線段樹"><a class="header-anchor" href="#非簡單操作線段樹"></a>非簡單操作線段樹</h3><h4 id="我們還是看個題目"><a class="header-anchor" href="#我們還是看個題目"></a>我們還是看個題目</h4><blockquote><p>現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有</p><ol><li>修改一個元素的值</li><li>查詢區間中最長的「好序列」長度</li></ol><p>定義一個「好區間」為：每個元素都是前一個元素 + 1</p><p>這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 <a href="http://toj.tfcis.org/oj/pro/365/" target="_blank" rel="noopener">這邊</a></p></blockquote><p>現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作</p><p>我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置<br>每次合併兩個區間就取兩邊紀錄的最長好序列的最大值</p><p>Emmm，但是感覺好像怪怪的<br>如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？</p><p>尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了</p><p>聽起來很複雜，但是其實一點也不</p><h4 id="piece"><a class="header-anchor" href="#piece"></a>piece</h4><p>為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piece</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查兩個 piece 是否相同</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == ( <span class="keyword">const</span> piece b )&#123;</span><br><span class="line">        <span class="keyword">return</span> l == b.l &amp;&amp; r == b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不想寫 operator（或是覺得太麻煩）可以這樣寫</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( piece a, piece b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l &amp;&amp; a.r == b.r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$l, r$ 就是這個區間的左右界<br>$sz$ 是大小，可有可無，只是寫 code 上方便</p><h4 id="node"><a class="header-anchor" href="#node"></a>node</h4><p>然後是 node</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    piece front, back, ma;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度<br>$ma$ 則是記錄當前線段樹區間內，最長的好序列長度</p><h4 id="merge"><a class="header-anchor" href="#merge"></a>merge</h4><p>接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">merge</span> <span class="params">( node L, node R )</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.front = L.front, res.back = R.back, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( basic[L.back.r] + <span class="number">1</span> == basic[R.front.l] )&#123;</span><br><span class="line">        piece swp = piece &#123; L.back.l, R.front.r, R.front.r - L.back.l + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( L.front == L.back )</span><br><span class="line">            res.front = swp;</span><br><span class="line">        <span class="keyword">if</span> ( R.front == R.back )</span><br><span class="line">            res.back = swp;</span><br><span class="line"></span><br><span class="line">        res.ma = ( swp.sz &gt; res.ma.sz ? swp : res.ma );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合併兩個區間後，要回傳的 res 內容如下</p><table><thead><tr><th>res 內的 piece</th><th>來源</th></tr></thead><tbody><tr><td>front</td><td>l.front</td></tr><tr><td>back</td><td>r.back</td></tr><tr><td>ma</td><td><a href="http://l.ma" target="_blank" rel="noopener">l.ma</a>, <a href="http://r.ma" target="_blank" rel="noopener">r.ma</a>, l.back + r.back 這三者中的最長好序列</td></tr></tbody></table><p>然後 update 以及 query 跟一般版的線段樹大同小異，可以自行閱讀面完整的 code</p><h4 id="code"><a class="header-anchor" href="#code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piece</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查兩個 piece 是否相同</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == ( <span class="keyword">const</span> piece b )&#123;</span><br><span class="line">        <span class="keyword">return</span> l == b.l &amp;&amp; r == b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不想寫 operator（或是覺得太麻煩）可以這樣寫</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( piece a, piece b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l &amp;&amp; a.r == b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    piece front, back, ma;</span><br><span class="line">&#125; seg[maxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> basic[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">merge</span> <span class="params">( node L, node R )</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.front = L.front, res.back = R.back, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( basic[L.back.r] + <span class="number">1</span> == basic[R.front.l] )&#123;</span><br><span class="line">        piece swp = piece &#123; L.back.l, R.front.r, R.front.r - L.back.l + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( L.front == L.back )</span><br><span class="line">            res.front = swp;</span><br><span class="line">        <span class="keyword">if</span> ( R.front == R.back )</span><br><span class="line">            res.back = swp;</span><br><span class="line"></span><br><span class="line">        res.ma = ( swp.sz &gt; res.ma.sz ? swp : res.ma );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        seg[n].front = seg[n].back = seg[n].ma = piece &#123; l, l, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( index &lt;= mid )</span><br><span class="line">            update ( l, mid, index, value, leftSon );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update ( mid + <span class="number">1</span>, r, index, value, rightSon );</span><br><span class="line"></span><br><span class="line">        seg[n] = merge ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class="line">        <span class="keyword">return</span> seg[n];</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class="number">1</span>, nowR, rightSon ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, type, l, r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; basic[i];</span><br><span class="line">        update ( <span class="number">1</span>, n, i, basic[i], <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )&#123;</span><br><span class="line">            basic[l] = r;</span><br><span class="line">            update ( <span class="number">1</span>, n, l, r, <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query ( l, r, <span class="number">1</span>, n, <span class="number">1</span> ).ma.sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BIT-Extra-2維BIT"><a class="header-anchor" href="#BIT-Extra-2維BIT"></a>BIT Extra - 2維BIT</h2><h4 id="已經成習慣的先看個題目"><a class="header-anchor" href="#已經成習慣的先看個題目"></a>已經成習慣的先看個題目</h4><blockquote><p>給定一平面，每個點都有權重，求查詢 $( x_1, y_1 ), ( x_2, y_2 )$ 所圍成區間的權重和，並且支援單點修改</p><p>$N, M \le 10^4, Q \le 10^5$</p></blockquote><p>暴力一定炸，那麼開 $N$ 顆線段樹 or BIT？</p><p>也不是不行，只是這樣可能還是會 TLE （複雜度 $O(QN\log M)$ ）</p><p>那麼就寫個二維 BIT 吧<br>概念上跟 BIT 一樣，另外需要做修改的行數跟一維 BIT 一樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BIT[maxN][maxN], n = <span class="number">100</span>, m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> in )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = x ; i &lt;= n ; i += i &amp; -i )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = y ; j &lt;= m ; j += j &amp; -j )</span><br><span class="line">            BIT[i][j] += in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> in )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = x ; i ; i -= i &amp; -i )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = y ; j ; j -= j &amp; -j )</span><br><span class="line">            res += BIT[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章以及教材</p><p>正因如此，內容上可能有些錯誤<br>如有發現錯誤，請聯絡 <a href="https://miohitokiri5474.github.io/code/about/">筆者</a></p><p>另外，這篇文章中的 code 也有同步更新於筆者的 github，可以看<a href="https://github.com/MiohitoKiri5474/CodesBackUp/tree/master/ncku-icpc/2020/week9/DLC" target="_blank" rel="noopener">這邊</a></p><p>本來還有預計要寫 Treap &amp; 動態開點<br>Treap 寫起來太耗費時間，就先欠著吧（？<br>而動態開點因為找不大到適合的題目，找到的題目後來想想可以用線段樹 + 離散化炸掉<br>雖然說用動態開點比較無腦，但是好像非必要，有興趣寫的人可以看這一題 <a href="https://toj.tfcis.org/oj/pro/242/" target="_blank" rel="noopener">TOJ 242 G. 色彩繽紛</a></p><p>至於資料結構的例題講解，這邊的 blog 有幾篇</p><ol><li><a href="https://miohitokiri5474.github.io/code/CF-920F/">[CF][920F] F. SUM AND REPLACE</a><br>這邊挺久之前寫的，可能語句有些不順</li><li><a href="https://miohitokiri5474.github.io/code/TOJ-391/">[TOJ][391] E. 模數 CANDY</a><br>這篇也挺久的，是高中時打過的比賽</li><li><a href="https://miohitokiri5474.github.io/code/TIOJ-1909/">[TIOJ][1909] 勇者出征</a><br>高中時寫到的哏題，也是離散化套線段樹<br>不過當時還有用噁心 define 的毒瘤習慣，code 看起來可能有些痛苦</li><li><a href="https://miohitokiri5474.github.io/code/TOJ-365/">[TOJ][365]G.大龍貓</a><br>最後是在文中有用到的題目大龍貓，當初也有寫一份題解<br>不過個人認為這邊的更好閱讀</li></ol><p>最後感謝閱讀到這邊的各位，謝謝大家</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang心情隨筆 #1</title>
      <link href="/code/gd-1/"/>
      <url>/code/gd-1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？</p><a id="more"></a><p>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include&lt;stdio.h&gt; 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C語言中 char 字串轉換成數字</title>
      <link href="/code/C-atoi/"/>
      <url>/code/C-atoi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:27 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字</p><a id="more"></a><h2 id="方法"><a class="header-anchor" href="#方法"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id="原理"><a class="header-anchor" href="#原理"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translate</span> <span class="params">( <span class="keyword">char</span> *c, <span class="keyword">int</span> len )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class="line">res *= <span class="number">10</span>;</span><br><span class="line">res += ( c[i] - <span class="string">'0'</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APCS] 2019年六月場實作題詳解</title>
      <link href="/code/APCS-19-06/"/>
      <url>/code/APCS-19-06/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:27 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p><a id="more"></a><p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src="/code/APCS-19-06/img.jpg" title="因為不想要縮圖是我的成績單，所以我就放這張圖了"><h2 id="problem-1"><a class="header-anchor" href="#problem-1"></a>problem 1</h2><h3 id="題目"><a class="header-anchor" href="#題目"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id="解法"><a class="header-anchor" href="#解法"></a>解法</h3><p>直接實作一下就好了</p><h3 id="code"><a class="header-anchor" href="#code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, ans = <span class="number">0</span>, swp;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; swp;</span><br><span class="line">        a += swp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; swp;</span><br><span class="line">        b += swp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += ( a &gt; b ? <span class="number">1</span> : <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; swp;</span><br><span class="line">        a += swp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; swp;</span><br><span class="line">        b += swp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += ( a &gt; b ? <span class="number">1</span> : <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !ans )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Draw"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( ans &gt; <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Win"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Lose"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-2"><a class="header-anchor" href="#problem-2"></a>problem 2</h2><h3 id="題目-v2"><a class="header-anchor" href="#題目-v2"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id="解法-v2"><a class="header-anchor" href="#解法-v2"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id="code-v2"><a class="header-anchor" href="#code-v2"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">105</span>; <span class="comment">// 大小我忘記了</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxN][maxN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, LL sum )</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先找出最低點</span></span><br><span class="line">    <span class="keyword">int</span> mi = min ( min ( mp[x + <span class="number">1</span>][y], mp[x - <span class="number">1</span>][y] ), min ( mp[x][y + <span class="number">1</span>], mp[x][y - <span class="number">1</span>] ) );</span><br><span class="line">    sum += mp[x][y];</span><br><span class="line">    mp[x][y] = INF;</span><br><span class="line">    <span class="keyword">if</span> ( mi == INF )</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span> ( mp[x + <span class="number">1</span>][y] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x + <span class="number">1</span>, y, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x - <span class="number">1</span>][y] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x - <span class="number">1</span>, y, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x][y + <span class="number">1</span>] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x, y + <span class="number">1</span>, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x][y - <span class="number">1</span>] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x, y - <span class="number">1</span>, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, x, y, mi = INF;</span><br><span class="line">    <span class="built_in">memset</span> ( mp, INF, <span class="keyword">sizeof</span> mp );</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            <span class="keyword">if</span> ( mi &gt; mp[i][j] )</span><br><span class="line">                mi = mp[i][j], x = i, y = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs ( x, y, <span class="number">0</span> ) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-3"><a class="header-anchor" href="#problem-3"></a>problem 3</h2><h3 id="題目-v3"><a class="header-anchor" href="#題目-v3"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id="定義一下互補字串"><a class="header-anchor" href="#定義一下互補字串"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \text&amp; B$為互補字串</p><h3 id="解法-v3"><a class="header-anchor" href="#解法-v3"></a>解法</h3><h4 id="解法一：硬幹"><a class="header-anchor" href="#解法一：硬幹"></a>解法一：硬幹</h4><h5 id="說明"><a class="header-anchor" href="#說明"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id="code-v3"><a class="header-anchor" href="#code-v3"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt; <span class="built_in">string</span>, <span class="keyword">int</span> &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str, basic;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++, c++ )</span><br><span class="line">        basic += c;</span><br><span class="line">    <span class="keyword">while</span> ( n-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="comment">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class="line">        sort ( str.begin(), str.end() );</span><br><span class="line">        <span class="comment">// 這邊則是要把重複的字元壓掉</span></span><br><span class="line">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class="line">        lib[str]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> j: lib )&#123;</span><br><span class="line">        str = basic;</span><br><span class="line">        <span class="comment">// 把出現過的直接刪掉</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: j.F )</span><br><span class="line">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class="line">        ans += j.S * lib[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因為會重複計算到兩次    </span></span><br><span class="line">    ans /= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：Xor"><a class="header-anchor" href="#方法二：Xor"></a>方法二：Xor</h4><h5 id="說明-v2"><a class="header-anchor" href="#說明-v2"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id="code-v4"><a class="header-anchor" href="#code-v4"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">translate</span> <span class="params">( <span class="built_in">string</span> str )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str )</span><br><span class="line">        res |= ( <span class="number">1</span> &lt;&lt; ( i - <span class="string">'A'</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>, ori = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )</span><br><span class="line">        ori |= ( <span class="number">1</span> &lt;&lt; i );</span><br><span class="line">    <span class="keyword">while</span> ( n-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="comment">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class="line">        sort ( str.begin(), str.end() );</span><br><span class="line">        <span class="comment">// 這邊則是要把重複的字元壓掉</span></span><br><span class="line">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class="line">        lib[translate ( str )]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> j: lib )</span><br><span class="line">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因為會重複計算到兩次    </span></span><br><span class="line">    ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id="problem-4"><a class="header-anchor" href="#problem-4"></a>problem 4</h2><h3 id="題目-v4"><a class="header-anchor" href="#題目-v4"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id="解法-v4"><a class="header-anchor" href="#解法-v4"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id="方法一：固定Window大小"><a class="header-anchor" href="#方法一：固定Window大小"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id="code-v5"><a class="header-anchor" href="#code-v5"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="comment">// 離散化</span></span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> &lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">    <span class="built_in">set</span> &lt; <span class="keyword">int</span> &gt; s;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        q.push ( data[i] );</span><br><span class="line">        s.insert ( data[i] );</span><br><span class="line">        cnt[data[i]]++;</span><br><span class="line">        <span class="keyword">if</span> ( q.size() &gt;= m )&#123;</span><br><span class="line">            cnt[q.front()]--;</span><br><span class="line">            <span class="keyword">if</span> ( !cnt[q.front()] )</span><br><span class="line">                s.erase ( q.front() );</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( s.size() == m )</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：不固定的window大小"><a class="header-anchor" href="#方法二：不固定的window大小"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href="https://brian.su/r/APCS-2019-06-P4" target="_blank" rel="noopener">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id="code-v6"><a class="header-anchor" href="#code-v6"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="comment">// 離散化</span></span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 這邊的話就不用set了    </span></span><br><span class="line">    <span class="built_in">queue</span> &lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="comment">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() &amp;&amp; cnt[data[i]] )&#123;</span><br><span class="line">            cnt[q.front()]--;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push ( data[i] );</span><br><span class="line">        cnt[data[i]]++;</span><br><span class="line">        <span class="keyword">if</span> ( q.size() == m )</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src="score.png" alt=""></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href="https://miohitokiri5474.github.io/code/about/">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id="更新（2019-07-04-10-28）"><a class="header-anchor" href="#更新（2019-07-04-10-28）"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src="/code/APCS-19-06/per.png" title="2019年六月場級距"><h2 id="圖片出處"><a class="header-anchor" href="#圖片出處"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href="https://www.instagram.com/kaji_nori06/" target="_blank" rel="noopener">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> APCS </tag>
            
            <tag> Full Contest Solution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Code Jam 2019 Qualification Round</title>
      <link href="/code/GCJ-2019-QuR/"/>
      <url>/code/GCJ-2019-QuR/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了</p><a id="more"></a><p>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705" target="_blank" rel="noopener">題目連結</a></p><h2 id="problem-A"><a class="header-anchor" href="#problem-A"></a>problem A</h2><h3 id="題目"><a class="header-anchor" href="#題目"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id="解法"><a class="header-anchor" href="#解法"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id="code"><a class="header-anchor" href="#code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, mi;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> tms = <span class="number">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; tms &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        mi = INF;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n.size() ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( n[i] == <span class="string">'4'</span> )&#123;</span><br><span class="line">                mi = min ( mi, i );</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'3'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; n[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = mi ; i &lt; n.size() ; i++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ( n[i] == <span class="string">'4'</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="後記"><a class="header-anchor" href="#後記"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id="problem-B"><a class="header-anchor" href="#problem-B"></a>problem B</h2><h3 id="題目-v2"><a class="header-anchor" href="#題目-v2"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src="pB.jpg" alt=""></p><h3 id="解法-v2"><a class="header-anchor" href="#解法-v2"></a>解法</h3><h4 id="O-N-2"><a class="header-anchor" href="#O-N-2"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">typedef</span> pair &lt; short, <span class="keyword">char</span> &gt; psc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> lib[maxN][maxN];</span><br><span class="line">psc str[maxN][maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, x, y;</span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> tms = <span class="number">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; data;</span><br><span class="line">        <span class="built_in">memset</span> ( lib, <span class="number">0</span>, <span class="keyword">sizeof</span> lib );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= n ; j++ )&#123;</span><br><span class="line">                str[i][j] = mp ( <span class="number">0</span>, <span class="string">' '</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )&#123;</span><br><span class="line">            lib[x][y] = <span class="literal">true</span>;</span><br><span class="line">            i == <span class="string">'S'</span> ? x++ : y++;</span><br><span class="line">        &#125;</span><br><span class="line">        lib[x][y] = <span class="literal">true</span>;</span><br><span class="line">        str[<span class="number">1</span>][<span class="number">1</span>] = mp ( <span class="number">0</span>, <span class="string">' '</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( lib[<span class="number">1</span>][i] )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( !lib[<span class="number">1</span>][i - <span class="number">1</span>] )&#123;</span><br><span class="line">                    str[<span class="number">1</span>][i] = str[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                    str[<span class="number">1</span>][i].F++;</span><br><span class="line">                    str[<span class="number">1</span>][i].S = <span class="string">'E'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[<span class="number">1</span>][i] = str[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                str[<span class="number">1</span>][i].F++;</span><br><span class="line">                str[<span class="number">1</span>][i].S = <span class="string">'E'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( lib[i][<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( !lib[i - <span class="number">1</span>][<span class="number">1</span>] )&#123;</span><br><span class="line">                    str[i][<span class="number">1</span>] = str[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                    str[i][<span class="number">1</span>].F++;</span><br><span class="line">                    str[i][<span class="number">1</span>].S = <span class="string">'S'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[i][<span class="number">1</span>] = str[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                str[i][<span class="number">1</span>].F++;</span><br><span class="line">                str[i][<span class="number">1</span>].S = <span class="string">'S'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( lib[i][j] )&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !lib[i][j - <span class="number">1</span>] )&#123;</span><br><span class="line">                        str[i][j] = str[i][j - <span class="number">1</span>];</span><br><span class="line">                        str[i][j].F++;</span><br><span class="line">                        str[i][j].S = <span class="string">'E'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        str[i][j] = str[i - <span class="number">1</span>][j];</span><br><span class="line">                        str[i][j].F++;</span><br><span class="line">                        str[i][j].S = <span class="string">'S'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( str[i][j - <span class="number">1</span>].F &gt; str[i - <span class="number">1</span>][j].F )&#123;</span><br><span class="line">                        str[i][j] = str[i][j - <span class="number">1</span>];</span><br><span class="line">                        str[i][j].S = <span class="string">'E'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        str[i][j] = str[i - <span class="number">1</span>][j];</span><br><span class="line">                        str[i][j].S = <span class="string">'S'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    str[i][j].F++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data = <span class="string">""</span>;</span><br><span class="line">        x = y = n;</span><br><span class="line">        <span class="keyword">while</span> ( str[x][y].S != <span class="string">' '</span> )&#123;</span><br><span class="line">            data += str[x][y].S;</span><br><span class="line">            str[x][y].S == <span class="string">'S'</span> ? x-- : y--;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse ( data.begin(), data.end() );</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; tms &lt;&lt; <span class="string">": "</span> &lt;&lt; data &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="O-N"><a class="header-anchor" href="#O-N"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- &amp;&amp; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; str )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ( i == <span class="string">'S'</span> ? <span class="string">'E'</span> : <span class="string">'S'</span> );</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-C"><a class="header-anchor" href="#problem-C"></a>problem C</h2><p>感謝 <a href="https://www.facebook.com/enminghuang1" target="_blank" rel="noopener">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id="code-v2"><a class="header-anchor" href="#code-v2"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input[maxN], l;</span><br><span class="line"><span class="keyword">char</span> out[maxN][<span class="number">2</span>], print[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">( <span class="keyword">int</span> idx, <span class="keyword">char</span> now )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( idx == l )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; print &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( out[idx][i] != now )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        print[idx] = out[idx][i];</span><br><span class="line">        <span class="keyword">if</span> ( idx == l - <span class="number">1</span> )</span><br><span class="line">            print[idx + <span class="number">1</span>] = out[idx][!i];</span><br><span class="line">        <span class="keyword">return</span> check ( idx + <span class="number">1</span>, out[idx][!i] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, idx;</span><br><span class="line">    <span class="built_in">set</span> &lt; <span class="keyword">int</span> &gt; prime;</span><br><span class="line">    <span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="keyword">char</span> &gt; lib;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">        <span class="built_in">memset</span> ( print, <span class="number">0</span>, <span class="keyword">sizeof</span> print );</span><br><span class="line">        prime.clear();</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; i++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; input[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( input[i] % j == <span class="number">0</span> )&#123;</span><br><span class="line">                    prime.insert ( j );</span><br><span class="line">                    prime.insert ( input[i] / j );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: prime )</span><br><span class="line">            lib[i] = <span class="string">'A'</span> + idx++;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; i++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= n ; j++ )</span><br><span class="line">                <span class="keyword">if</span> ( input[i] % j == <span class="number">0</span> )&#123;</span><br><span class="line">                    out[i][<span class="number">0</span>] = lib[j];</span><br><span class="line">                    out[i][<span class="number">1</span>] = lib[input[i] / j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( check ( <span class="number">0</span>, out[<span class="number">0</span>][i] ) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記-v2"><a class="header-anchor" href="#後記-v2"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src="scb.jpg" alt=""></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br>= =</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Full Contest Solution </tag>
            
            <tag> GCJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TIOJ][1909] 勇者出征</title>
      <link href="/code/TIOJ-1909/"/>
      <url>/code/TIOJ-1909/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1909" target="_blank" rel="noopener">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的</p><a id="more"></a><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id="建圖"><a class="header-anchor" href="#建圖"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id="暴力-O-N-2"><a class="header-anchor" href="#暴力-O-N-2"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-1</span>, r = n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j-- )</span><br><span class="line">        <span class="keyword">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class="line">            l = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j++ )</span><br><span class="line">        <span class="keyword">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class="line">            r = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> &amp;&amp; r == n )</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> )&#123;</span><br><span class="line">        UNI ( r, i, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( r == n )&#123;</span><br><span class="line">        UNI ( l, i, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="線段樹-O-NlogN"><a class="header-anchor" href="#線段樹-O-NlogN"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class="line"><span class="comment">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class="line"><span class="keyword">int</span> seg1[maxN &lt;&lt; <span class="number">2</span>], seg2[maxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib是已經做完離散化的數列</span></span><br><span class="line"><span class="built_in">memset</span> ( seg1, INF, <span class="keyword">sizeof</span> seg1 );</span><br><span class="line"><span class="built_in">memset</span> ( seg2, <span class="number">-1</span>, <span class="keyword">sizeof</span> seg2 )</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line">    update1 ( <span class="number">0</span>, n, i, lib[i], <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">    <span class="keyword">int</span> l = query2 ( lib[i] + <span class="number">1</span>, n, <span class="number">0</span>, n, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">int</span> r = query1 ( lib[i] + <span class="number">1</span>, n, <span class="number">0</span>, n, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> &amp;&amp; r == INF )</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> )&#123;</span><br><span class="line">        UNI ( i, r, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( r == INF )&#123;</span><br><span class="line">        UNI ( i, l, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges );</span><br><span class="line"></span><br><span class="line">    update1 ( <span class="number">0</span>, n, INF, lib[i], <span class="number">1</span> );</span><br><span class="line">    update2 ( <span class="number">0</span>, n, i, lib[i], <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="單調列隊優化-O-N"><a class="header-anchor" href="#單調列隊優化-O-N"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href="https://goo.gl/e12UAo" target="_blank" rel="noopener">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// data 是原數列</span></span><br><span class="line"><span class="built_in">stack</span> &lt; pii, <span class="built_in">vector</span> &lt; pii &gt; &gt; st;</span><br><span class="line"><span class="comment">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class="line">pii swp;</span><br><span class="line">st.push ( pii ( data[<span class="number">0</span>], <span class="number">0</span> ) );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class="line">        swp = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> ( EMP ( st ) )</span><br><span class="line">            UNI ( swp.S, i, edges );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class="line">    &#125;</span><br><span class="line">    st.push ( pii ( data[i], i ) );</span><br><span class="line">&#125;</span><br><span class="line">swp = st.top();</span><br><span class="line">st.pop();</span><br><span class="line"><span class="keyword">while</span> ( !st.empty() )&#123;</span><br><span class="line">    UNI ( swp.S, st.top().S, edges );</span><br><span class="line">    swp = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是時候來處理路徑囉"><a class="header-anchor" href="#是時候來處理路徑囉"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義<br>$$dp[u] = u的子孫數目（包含 u ）$$</p><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦<br>$$( 總點數 - dp[n] - 1 )\times ( dp[n] - 1 )$$</p><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; edges[maxN];</span><br><span class="line"><span class="keyword">int</span> cnt[maxN], dp[maxN], N;</span><br><span class="line"><span class="comment">// N = 總點數 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n,  <span class="keyword">int</span> p )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>, b = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( a == <span class="number">-1</span> )</span><br><span class="line">            a = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = i;</span><br><span class="line">        dfs ( i, n );</span><br><span class="line">        dp[n] += dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class="comment">// 祖先到子孫</span></span><br><span class="line">    <span class="keyword">if</span> ( deges[n].size() == <span class="number">3</span> ) <span class="comment">// 如果是有兩個子孫的話</span></span><br><span class="line">        cnt[n] += dp[a] * dp[b];</span><br><span class="line">    dp[n]++; <span class="comment">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class="line">    cnt[n] += N;</span><br><span class="line">    cnt[n] &lt;&lt;= <span class="number">1</span>; <span class="comment">// 記得乘二喔</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><p>綜合以上，我的code長這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; edges[maxN];</span><br><span class="line">LL dp[maxN], N, cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n,  <span class="keyword">int</span> p )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>, b = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( a == <span class="number">-1</span> )</span><br><span class="line">            a = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = i;</span><br><span class="line">        dfs ( i, n );</span><br><span class="line">        dp[n] += dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class="line">    <span class="keyword">if</span> ( edges[n].size() == <span class="number">3</span> )</span><br><span class="line">        cnt[n] += dp[a] * dp[b];</span><br><span class="line">    dp[n]++;</span><br><span class="line">    cnt[n] += N;</span><br><span class="line">    cnt[n] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, idx = <span class="number">-1</span>;</span><br><span class="line">    LL ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> &lt; pii, <span class="built_in">vector</span> &lt; pii &gt; &gt; st;</span><br><span class="line">    pii swp;</span><br><span class="line">    st.push ( pii ( data[<span class="number">0</span>], <span class="number">0</span> ) );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =  <span class="number">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class="line">            swp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> ( st.empty() )</span><br><span class="line">                UNI ( swp.S, i, edges );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class="line">        &#125;</span><br><span class="line">        st.push ( pii ( data[i], i ) );</span><br><span class="line">    &#125;</span><br><span class="line">    swp = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    <span class="keyword">while</span> ( !st.empty() )&#123;</span><br><span class="line">        UNI ( swp.S, st.top().S, edges );</span><br><span class="line">        swp = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    N = n - <span class="number">1</span>;</span><br><span class="line">    dfs ( <span class="number">0</span>, <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( cnt[i] &gt; ma )</span><br><span class="line">            ma = cnt[i], idx = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ma &lt;&lt; <span class="string">' '</span> &lt;&lt; idx + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 &lt;3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> TIOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF]Round 521</title>
      <link href="/code/CFR521/"/>
      <url>/code/CFR521/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦</p><a id="more"></a><p>先放上所有題目的<a href="http://codeforces.com/contest/1077" target="_blank" rel="noopener">連結</a></p><h2 id="problem-A"><a class="header-anchor" href="#problem-A"></a>problem A</h2><h3 id="題目"><a class="header-anchor" href="#題目"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id="解法"><a class="header-anchor" href="#解法"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id="code"><a class="header-anchor" href="#code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, k, a, b, swp, ans;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">        swp = a - b;</span><br><span class="line">        ans = swp * ( LL ) ( k / <span class="number">2</span> );</span><br><span class="line">        <span class="keyword">if</span> ( k &amp; <span class="number">1</span> )</span><br><span class="line">            ans += a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-B"><a class="header-anchor" href="#problem-B"></a>problem B</h2><h3 id="題目-v2"><a class="header-anchor" href="#題目-v2"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id="解法-v2"><a class="header-anchor" href="#解法-v2"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id="code-v2"><a class="header-anchor" href="#code-v2"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !data[i] &amp;&amp; data[i - <span class="number">1</span>] &amp;&amp; data[i + <span class="number">1</span>] )</span><br><span class="line">            lib.push_back ( i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">while</span> ( lib.size() &gt; <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( lib[<span class="number">1</span>] - lib[<span class="number">0</span>] == <span class="number">2</span> )&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !lib.empty() )</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-C"><a class="header-anchor" href="#problem-C"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id="題目-v3"><a class="header-anchor" href="#題目-v3"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \to 8 = 3 + 5$</li></ol><h3 id="解法-v3"><a class="header-anchor" href="#解法-v3"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id="code-v3"><a class="header-anchor" href="#code-v3"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n ), ans;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        sum += i;</span><br><span class="line">        lib[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        sum -= data[i];</span><br><span class="line">        <span class="keyword">if</span> ( sum &amp; <span class="number">1</span> )&#123;</span><br><span class="line">            sum += data[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ( lib[sum] == <span class="number">1</span> &amp;&amp; sum != data[i] ) || lib[sum] &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            ans.push_back ( i + <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        sum &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-D"><a class="header-anchor" href="#problem-D"></a>problem D</h2><h3 id="題目-v4"><a class="header-anchor" href="#題目-v4"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id="解法-v4"><a class="header-anchor" href="#解法-v4"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id="code-v4"><a class="header-anchor" href="#code-v4"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN], m, k, ma;</span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; lib;</span><br><span class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; &gt; table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span> <span class="params">( <span class="keyword">int</span> tms )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = tms ; i &lt; ma ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> j: table[i] )</span><br><span class="line">            res += cnt[j] / tms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, l = <span class="number">0</span>, r = <span class="number">-1</span>, mid;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span> ( n == k )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )&#123;</span><br><span class="line">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class="line">        r = max ( r, cnt[i] );</span><br><span class="line">        table[cnt[i]].push_back ( i );</span><br><span class="line">    &#125;</span><br><span class="line">    ma = ++r;</span><br><span class="line">    mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( r - l &gt; <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( check ( mid ) )</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">        mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = k;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; min ( cnt[i] / mid, l ) ; j++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lib[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        l -= min ( cnt[i] / mid, l );</span><br><span class="line">        <span class="keyword">if</span> ( !l )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-E"><a class="header-anchor" href="#problem-E"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id="題目-v5"><a class="header-anchor" href="#題目-v5"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id="解法-v5"><a class="header-anchor" href="#解法-v5"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id="code-v5"><a class="header-anchor" href="#code-v5"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line">LL cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ma, ans = <span class="number">-1</span>, swp, idx, id;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: data )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class="line"></span><br><span class="line">    data.clear();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class="line">        data.push_back ( cnt[i] );</span><br><span class="line">    &#125;</span><br><span class="line">    sort ( data.begin(), data.end() );</span><br><span class="line">    ma = data.back() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ma ; i++ )&#123;</span><br><span class="line">        swp = idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= <span class="number">1</span> )&#123;</span><br><span class="line">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class="line">            <span class="keyword">if</span> ( id &lt; data.size() )</span><br><span class="line">                swp += j;</span><br><span class="line">            idx = id + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = max ( ans, swp );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Full Contest Solution </tag>
            
            <tag> CodeForces </tag>
            
            <tag> div.3 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TIOJ][1615] A! + B! problem</title>
      <link href="/code/TIOJ-1615/"/>
      <url>/code/TIOJ-1615/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）</p><a id="more"></a><p>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id="題目-解法"><a class="header-anchor" href="#題目-解法"></a>題目 &amp; 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href="https://tioj.ck.tp.edu.tw/problems/1615" target="_blank" rel="noopener">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span> &lt; maxN &gt; lib;</span><br><span class="line"><span class="built_in">vector</span> &lt; LL &gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    lib[<span class="number">0</span>] = lib[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; maxN ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !lib[i] )&#123;</span><br><span class="line">            prime.push_back ( i );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i ; j &lt; maxN ; j += i )</span><br><span class="line">                lib[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, len = prime.size();</span><br><span class="line">    LL ans, stp;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( a &gt; b )</span><br><span class="line">            swap ( a, b );</span><br><span class="line">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class="line">        stp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = a + <span class="number">1</span> ; i &lt;= b ; i++ )&#123;</span><br><span class="line">            stp *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        stp++;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans ; i++ )&#123;</span><br><span class="line">            <span class="keyword">while</span> ( stp % prime[i] == <span class="number">0</span> )&#123;</span><br><span class="line">                stp /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = ans ; i &lt; len ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( !( stp % prime[i] ) )&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">while</span> ( stp % prime[i] == <span class="number">0</span> )</span><br><span class="line">                    stp /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( stp &gt; maxN )</span><br><span class="line">            ans++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 &lt;3</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> TIOJ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ITSA] No.66 詳解</title>
      <link href="/code/itsa-66/"/>
      <url>/code/itsa-66/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ</p><a id="more"></a><h2 id="problem-1"><a class="header-anchor" href="#problem-1"></a>problem 1</h2><h3 id="題目"><a class="header-anchor" href="#題目"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 &lt; 11個）<br>求該行出現率「超過」一半的整數</p><h3 id="解法"><a class="header-anchor" href="#解法"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id="code"><a class="header-anchor" href="#code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> in, cnt;</span><br><span class="line">    <span class="keyword">bool</span> ans;</span><br><span class="line">    <span class="keyword">while</span> ( getline ( <span class="built_in">cin</span>, str ) )&#123;</span><br><span class="line">        lib.clear();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span> <span class="params">( str )</span></span>;</span><br><span class="line">        <span class="keyword">while</span> ( ss &gt;&gt; in )&#123;</span><br><span class="line">            lib[in]++;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: lib )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( i.S &gt; cnt / <span class="number">2</span> )&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i.F &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !ans )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-2"><a class="header-anchor" href="#problem-2"></a>problem 2</h2><h3 id="題目-v2"><a class="header-anchor" href="#題目-v2"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id="解法-v2"><a class="header-anchor" href="#解法-v2"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 &lt;3</p><h3 id="code-v2"><a class="header-anchor" href="#code-v2"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, len, x, a, b, ans;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span> ( getline ( <span class="built_in">cin</span>, str ) )&#123;</span><br><span class="line">        len = str.size(), x = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( str[i] == <span class="string">'+'</span> )</span><br><span class="line">                opt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'-'</span> )</span><br><span class="line">                opt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'*'</span> )</span><br><span class="line">                opt = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'/'</span> )</span><br><span class="line">                opt = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="string">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span> )&#123;</span><br><span class="line">                    x = x * <span class="number">10</span> + <span class="keyword">int</span> ( str[i] - <span class="string">'0'</span> );</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( flag )</span><br><span class="line">                        lib.pb ( x );</span><br><span class="line">                    x = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag )</span><br><span class="line">            lib.pb ( x );</span><br><span class="line">        a = lib[<span class="number">0</span>], b = lib[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ( !opt )</span><br><span class="line">            ans = ( b - a ) * <span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( opt == <span class="number">1</span> )</span><br><span class="line">            ans = ( b + a ) * <span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( opt == <span class="number">2</span> )</span><br><span class="line">            ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) b / a * <span class="number">10.0</span> );</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( str[<span class="number">0</span>] == <span class="string">'x'</span> )</span><br><span class="line">                ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) b * a * <span class="number">10.0</span> );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) a / b * <span class="number">10.0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans / <span class="number">10</span> &lt;&lt; <span class="string">'.'</span> &lt;&lt; ans % <span class="number">10</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-3"><a class="header-anchor" href="#problem-3"></a>problem 3</h2><h3 id="題目-v3"><a class="header-anchor" href="#題目-v3"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id="解法-v3"><a class="header-anchor" href="#解法-v3"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id="code-v3"><a class="header-anchor" href="#code-v3"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str, swp;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    getline ( <span class="built_in">cin</span>, str );</span><br><span class="line">    <span class="keyword">while</span> ( t-- )&#123;</span><br><span class="line">        getline ( <span class="built_in">cin</span>, str );</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Tokens found:\n"</span>;</span><br><span class="line">        swp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="string">':'</span> || i == <span class="string">','</span> || i == <span class="string">';'</span> )&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; swp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                swp = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swp += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( swp != <span class="string">""</span> )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; swp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-4"><a class="header-anchor" href="#problem-4"></a>problem 4</h2><h3 id="題目-v4"><a class="header-anchor" href="#題目-v4"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id="解法-v4"><a class="header-anchor" href="#解法-v4"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成&quot;IIII&quot;，正確應該是&quot;IX&quot;<br>垃圾是我QQ</p><h3 id="code-v4"><a class="header-anchor" href="#code-v4"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by.MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> lib0[<span class="number">10</span>] = &#123; <span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> lib1[<span class="number">10</span>] = &#123; <span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> lib2[<span class="number">10</span>] = &#123; <span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, in;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lib2[in / <span class="number">100</span>] &lt;&lt; lib1[in % <span class="number">100</span> / <span class="number">10</span>] &lt;&lt; lib0[in % <span class="number">10</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-5"><a class="header-anchor" href="#problem-5"></a>problem 5</h2><h3 id="題目-v5"><a class="header-anchor" href="#題目-v5"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id="解法-v5"><a class="header-anchor" href="#解法-v5"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id="code-v5"><a class="header-anchor" href="#code-v5"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>], ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> a, b, str;</span><br><span class="line">    <span class="built_in">set</span> &lt; <span class="built_in">string</span> &gt; lib;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class="line">        <span class="keyword">int</span> szA = a.size(), szB = b.size();</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="built_in">memset</span> ( dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp );</span><br><span class="line">        ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( a[i] == b[j] )&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                    ma = max ( ma, dp[i + <span class="number">1</span>][j + <span class="number">1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !ma )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No common sequence!\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> ( dp[i + <span class="number">1</span>][j + <span class="number">1</span>] == ma )&#123;</span><br><span class="line">                    str = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">for</span> ( <span class="keyword">int</span> k = i - ma + <span class="number">1</span> ; k &lt;= i ; k++ )</span><br><span class="line">                        str += a[k];</span><br><span class="line">                    lib.insert ( str );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: lib )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Full Contest Solution </tag>
            
            <tag> ITSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disjoint Set 並查集</title>
      <link href="/code/dsu/"/>
      <url>/code/dsu/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結</p><a id="more"></a><h2 id="disjoint-set-並查集"><a class="header-anchor" href="#disjoint-set-並查集"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disjoint set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 10005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; maxN ; i++ )</span><br><span class="line">        dis[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    dis[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路徑壓縮"><a class="header-anchor" href="#路徑壓縮"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( dis[n] == n )</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> dis[n] = find ( n );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後這個東西的複雜度會變成均攤 $O ( \log N )$，感覺還不錯</p><h3 id="避免-Stack-Overflow"><a class="header-anchor" href="#避免-Stack-Overflow"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id="方法一：random"><a class="header-anchor" href="#方法一：random"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    dis[a] = b;</span><br><span class="line">    find ( rand() % n );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：Union-by-rank"><a class="header-anchor" href="#方法二：Union-by-rank"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rk[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( rk[a] &lt; rk[b] )</span><br><span class="line">        swap ( a, b );</span><br><span class="line">    dis[b] = a;</span><br><span class="line">    rk[b] = rk[a] + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id="方法三：Union-by-size"><a class="header-anchor" href="#方法三：Union-by-size"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( sz[a] &gt; sz[b] )</span><br><span class="line">        swap ( a, b );</span><br><span class="line">    dis[a] = b;</span><br><span class="line">    sz[b] += sz[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果開優化還是爛了呢"><a class="header-anchor" href="#如果開優化還是爛了呢"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id="確認是否屬於同一個並查集"><a class="header-anchor" href="#確認是否屬於同一個並查集"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> dsu </tag>
            
            <tag> disjoint set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TOJ][420] C. 藏寶圖</title>
      <link href="/code/TOJ-420/"/>
      <url>/code/TOJ-420/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ</p><a id="more"></a><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>先附上<a href="https://toj.tfcis.org/oj/pro/420/" target="_blank" rel="noopener">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id="先備知識"><a class="header-anchor" href="#先備知識"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id="最小生成樹"><a class="header-anchor" href="#最小生成樹"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id="樹直徑"><a class="header-anchor" href="#樹直徑"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id="作法"><a class="header-anchor" href="#作法"></a>作法</h2><h3 id="Kruskal"><a class="header-anchor" href="#Kruskal"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href="https://miohitokiri5474.github.io/code/dsu/">這篇</a></p><h3 id="樹直徑-v2"><a class="header-anchor" href="#樹直徑-v2"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"><span class="keyword">typedef</span> pair &lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">( node a, node b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxN];</span><br><span class="line">LL dist[maxN];</span><br><span class="line"><span class="built_in">vector</span> &lt; node &gt; edges;</span><br><span class="line"><span class="built_in">vector</span> &lt; pii &gt; mst[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; maxN ; i++ )</span><br><span class="line">        dis[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    dis[find ( a )] = find ( b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: edges )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Union ( i.u, i.v );</span><br><span class="line">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class="line">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">int</span> p )</span></span>&#123; <span class="comment">// 樹直徑</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: mst[n] )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i.F == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[i.F] = dist[n] + i.S;</span><br><span class="line">        dfs ( i.F, n );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v, w, t, idx, now;</span><br><span class="line">    LL ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edges.pb ( node &#123; u, v, w &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Kruskal();</span><br><span class="line"></span><br><span class="line">    dfs ( <span class="number">0</span>, <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( ma &lt; dist[i] )</span><br><span class="line">            ma = dist[i], idx = i;</span><br><span class="line"></span><br><span class="line">    dist[idx] = <span class="number">0</span>;</span><br><span class="line">    dfs ( idx, <span class="number">-1</span> );</span><br><span class="line">    ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line">        ma = max ( ma, dist[i] );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ma &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記"><a class="header-anchor" href="#後記"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id="更新-2019-03-06"><a class="header-anchor" href="#更新-2019-03-06"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 &gt; &lt;</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> TOJ </tag>
            
            <tag> MST </tag>
            
            <tag> dsu </tag>
            
            <tag> 樹直徑 </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TOJ][407] D. 警力配置</title>
      <link href="/code/TOJ-407/"/>
      <url>/code/TOJ-407/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>我先附上<a href="http://toj.tfcis.org/oj/pro/407/" target="_blank" rel="noopener">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組</p><a id="more"></a><p>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href="http://www.csie.ntnu.edu.tw/~u91029/Matching.html" target="_blank" rel="noopener">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; edges[maxN];</span><br><span class="line"><span class="keyword">int</span> match[maxN], visit[maxN], turn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    visit[n] = turn;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i] == <span class="number">-1</span> || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123;</span><br><span class="line">            match[i] = n;</span><br><span class="line">            match[n] = i;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, m, u, v, p, q, ans;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- )&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span> ( match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;i: edges )</span><br><span class="line">            i.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            v += p;</span><br><span class="line">            edges[u].pb ( v );</span><br><span class="line">            edges[v].pb ( u );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p += q;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= p ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( match[i] == <span class="number">-1</span> )&#123;</span><br><span class="line">                turn++;</span><br><span class="line">                <span class="comment">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class="line">                <span class="keyword">if</span> ( dfs ( i ) )</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="comment">// 如果可以找到新的配對就 ans++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tips"><a class="header-anchor" href="#tips"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> TOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF][999E] E. REACHABILITY FROM THE CAPITAL</title>
      <link href="/code/CF-999E/"/>
      <url>/code/CF-999E/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:27 GMT+0800 (Taipei Standard Time) --><h2 id="題目-解法"><a class="header-anchor" href="#題目-解法"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href="http://codeforces.com/problemset/problem/999/E" target="_blank" rel="noopener">連結</a></p><a id="more"></a><p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 5005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; edges[maxN];</span><br><span class="line"><span class="keyword">int</span> pa[maxN];</span><br><span class="line"><span class="keyword">bool</span> used[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">int</span> p )</span></span>&#123;</span><br><span class="line">    used[n] = <span class="literal">true</span>;</span><br><span class="line">    pa[n] = p;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( used[i] )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs ( i, p );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, s, u, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        edges[u].push_back ( v );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs ( s, s );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( pa[i] == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">memset</span> ( used, <span class="number">0</span>, <span class="keyword">sizeof</span> used );</span><br><span class="line">            dfs ( i, i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> &lt; <span class="keyword">int</span> &gt; lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( pa[i] != s )</span><br><span class="line">            lib.insert ( pa[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lib.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tips"><a class="header-anchor" href="#tips"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> div.3 </tag>
            
            <tag> graph </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TOJ][406] C. 軍隊部署</title>
      <link href="/code/TOJ-406/"/>
      <url>/code/TOJ-406/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>老樣子先放連結<br>[TOJ](&lt;<a href="http://toj.tfcis.org/oj/pro/406/" target="_blank" rel="noopener">http://toj.tfcis.org/oj/pro/406/</a>)<br>[ZJ](&lt;<a href="https://zerojudge.tw/ShowProblem?problemid=c460" target="_blank" rel="noopener">https://zerojudge.tw/ShowProblem?problemid=c460</a>)<br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊</p><a id="more"></a><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, x, y, z, w, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        dp[w][x * <span class="number">4</span> + y * <span class="number">2</span> + z]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">8</span> ; j++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">8</span> ; k++ )</span><br><span class="line">                <span class="keyword">if</span> ( ( i | j | k ) == <span class="number">7</span> )</span><br><span class="line">                    ans += dp[<span class="number">1</span>][i] * dp[<span class="number">2</span>][j] * dp[<span class="number">3</span>][k];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> TOJ </tag>
            
            <tag> ZJ </tag>
            
            <tag> 全國賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF][920F] F. SUM AND REPLACE</title>
      <link href="/code/CF-920F/"/>
      <url>/code/CF-920F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:27 GMT+0800 (Taipei Standard Time) --><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education</p><a id="more"></a><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href="http://codeforces.com/problemset/problem/920/F" target="_blank" rel="noopener">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 ${1, 2, 3, 6}$，共四個）</p><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href="https://miohitokiri.github.io/code/TOJ-391/" target="_blank" rel="noopener">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\ge 2\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 ${ 1, 1, 1, 3 }$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 300005</span></span><br><span class="line"></span><br><span class="line">LL sum[maxN &lt;&lt; <span class="number">2</span>], dp[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">bool</span> used[maxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; prime;</span><br><span class="line"><span class="built_in">bitset</span> &lt; 1005 &gt; lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">D</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( dp[n] != <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">double</span> www = <span class="built_in">sqrt</span> ( n );</span><br><span class="line">    <span class="keyword">int</span> ma = www, res = <span class="number">0</span>, maa = ma + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; maa ; i++ )</span><br><span class="line">        n % i ? res : res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n] = res * <span class="number">2</span> - ( www == ma ? <span class="number">1</span> : <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sum[n];</span><br><span class="line">        used[n] = ( sum[n] &gt; <span class="number">2</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        build ( l, mid, leftSon );</span><br><span class="line">        build ( mid + <span class="number">1</span>, r, rightSon );</span><br><span class="line"></span><br><span class="line">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class="line">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class="line">        <span class="keyword">return</span> sum[n];</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">    <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !used[n] )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nowL == nowR )&#123;</span><br><span class="line">        sum[n] = D ( sum[n] );</span><br><span class="line">        used[n] = ( sum[n] &gt; <span class="number">2</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">            modify ( l, r, nowL, mid, leftSon );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            modify ( l, r, nowL, mid, leftSon );</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class="line">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    lib[<span class="number">0</span>] = lib[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; <span class="number">1005</span> ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !lib[i] )&#123;</span><br><span class="line">            prime.push_back ( i );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i &lt;&lt; <span class="number">1</span> ; j &lt; <span class="number">1005</span> ; j += i )</span><br><span class="line">                lib[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span> ( dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp );</span><br><span class="line">    <span class="keyword">int</span> n, m, type, l, r, stop;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    build ( <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )</span><br><span class="line">            modify ( l, r, <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query ( l, r, <span class="number">1</span>, n, <span class="number">1</span> ) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="證明（？"><a class="header-anchor" href="#證明（？"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \frac{N}{i} \to i \times j = N$<br>假設 $i\le j$ 帶入上面的式子，$i^2\le N\to i\le\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;<br>以上證明僅供參考</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> Education Round </tag>
            
            <tag> segment tree </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TOJ][391] E. 模數 CANDY</title>
      <link href="/code/TOJ-391/"/>
      <url>/code/TOJ-391/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目-解法"><a class="header-anchor" href="#題目-解法"></a>題目 &amp; 解法</h2><p>我先附上題目<a href="http://toj.tfcis.org/oj/pro/391/" target="_blank" rel="noopener">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong></p><a id="more"></a><p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seg[maxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        seg[n] += value;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( index &lt;= mid )</span><br><span class="line">            update ( l, mid, index, value, leftSon );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update ( mid + <span class="number">1</span>, r, index, value, rightSon );</span><br><span class="line"></span><br><span class="line">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( seg[n] &lt; value )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nowL == nowR )</span><br><span class="line">        seg[n] %= value;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, value, rightSon );</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class="line">            modify ( mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, nowR, value, rightSon );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, type, l, r, x, in;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">        update ( <span class="number">0</span>, n, i, in, <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            update ( <span class="number">0</span>, n, r, l, <span class="number">1</span> );</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( type == <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            modify ( l, r, <span class="number">0</span>, n, x, <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; seg[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id="證明"><a class="header-anchor" href="#證明"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \lbrace a_i \rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> segment tree </tag>
            
            <tag> TOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TIOJ][1795] 咕嚕咕嚕呱啦呱啦</title>
      <link href="/code/TIOJ-1795/"/>
      <url>/code/TIOJ-1795/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>題目連結<a href="https://tioj.ck.tp.edu.tw/problems/1795" target="_blank" rel="noopener">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$</p><a id="more"></a><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：<br>$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$<br>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\le k\e ub$ 的生成樹</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bridge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">disjionSet</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis[maxN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span> <span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; maxN ; i++ )</span><br><span class="line">            dis[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">        dis[find ( a )] = find ( b );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; bridge &gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">( bridge a, bridge b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, k, u, v, w, ub = <span class="number">0</span>, lb = <span class="number">0</span>;</span><br><span class="line">    disjionSet dis;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> ( m-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edges.push_back ( bridge &#123; u, v, w &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class="line">    dis.Init();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dis.Union ( i.u, i.v );</span><br><span class="line">        lb += i.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    reverse ( edges.begin(), edges.end() );</span><br><span class="line">    dis.Init();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dis.Union ( i.u, i.v );</span><br><span class="line">        ub += i.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? <span class="string">"TAK"</span> : <span class="string">"NIE"</span> ) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> TIOJ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVA][00459]GRAPH CONNECTIVITY</title>
      <link href="/code/uva00459/"/>
      <url>/code/uva00459/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目-解法"><a class="header-anchor" href="#題目-解法"></a>題目 &amp; 解法</h2><p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400" target="_blank" rel="noopener">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）</p><a id="more"></a><p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define tools</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPALL(i,n) for ( auto &amp;i: n )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span> &lt; <span class="keyword">int</span> &gt; si;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(n) n.clear()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GL(n) getline ( cin, n )</span></span><br><span class="line"></span><br><span class="line">si edge[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> go[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    go[n] = <span class="literal">true</span>;</span><br><span class="line">    REPALL ( i, edge[n] )</span><br><span class="line">        <span class="keyword">if</span> ( !go[i] )</span><br><span class="line">            dfs ( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n, u, v, ans, cnt = <span class="number">0</span>, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">while</span> ( t-- )&#123;</span><br><span class="line">        GL ( str );</span><br><span class="line">        MEM ( go, <span class="number">0</span> );</span><br><span class="line">        REPP ( i, <span class="number">0</span>, <span class="number">30</span> )</span><br><span class="line">            CLR ( edge[i] );</span><br><span class="line"></span><br><span class="line">        n = str[<span class="number">0</span>] - <span class="string">'A'</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( GL ( str ) )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( EMP ( str ) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            u = str[<span class="number">0</span>] - <span class="string">'A'</span>, v = str[<span class="number">1</span>] - <span class="string">'A'</span>;</span><br><span class="line">            edge[u].insert ( v );</span><br><span class="line">            edge[v].insert ( u );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n++;</span><br><span class="line">        REPP ( i, <span class="number">0</span>, n )</span><br><span class="line">            <span class="keyword">if</span> ( !go[i] )&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs ( i );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !cnt++ )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( cnt++ &gt; <span class="number">2</span> )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> dfs </tag>
            
            <tag> UVa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TOJ][365]G.大龍貓</title>
      <link href="/code/TOJ-365/"/>
      <url>/code/TOJ-365/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href="http://toj.tfcis.org/oj/pro/365/" target="_blank" rel="noopener">題目原網址</a></p><a id="more"></a><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piece</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, s, sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( piece a, piece b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.f == b.f &amp;&amp; a.s == b.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    piece fro, bck, ma;</span><br><span class="line">&#125; seg[maxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> basic[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">up</span> <span class="params">( node L, node R )</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( basic[L.bck.s] + <span class="number">1</span> == basic[R.fro.f] )&#123;</span><br><span class="line">        piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( same ( L.fro, L.bck ) )</span><br><span class="line">            res.fro = stop;</span><br><span class="line">        <span class="keyword">if</span> ( same ( R.fro, R.bck ) )</span><br><span class="line">            res.bck = stop;</span><br><span class="line"></span><br><span class="line">        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        build ( l, mid, leftSon );</span><br><span class="line">        build ( mid + <span class="number">1</span>, r, rightSon );</span><br><span class="line"></span><br><span class="line">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Index, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( Index &lt;= mid )</span><br><span class="line">        update ( l, mid, Index, leftSon );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        update ( mid + <span class="number">1</span>, r, Index, rightSon );</span><br><span class="line"></span><br><span class="line">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class="line">        <span class="keyword">return</span> seg[n];</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class="number">1</span>, leftSon = n &lt;&lt; <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r &lt;= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">    <span class="keyword">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class="number">1</span>, nowR, rightSon ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r, type;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; basic[i];</span><br><span class="line">    build ( <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> ( q-- )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )&#123;</span><br><span class="line">            basic[l] = r;</span><br><span class="line">            update ( <span class="number">1</span>, n, l, <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query ( l, r, <span class="number">1</span>, n, <span class="number">1</span> ).ma.sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> segment tree </tag>
            
            <tag> TOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TIOJ][1940]Nim</title>
      <link href="/code/TIOJ-1940/"/>
      <url>/code/TIOJ-1940/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 04 2020 16:51:28 GMT+0800 (Taipei Standard Time) --><h2 id="題目"><a class="header-anchor" href="#題目"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href="https://tioj.ck.tp.edu.tw/problems/1940" target="_blank" rel="noopener">在這</a></p><a id="more"></a><h2 id="解法"><a class="header-anchor" href="#解法"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：<br>$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$<br>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\frac{n}{4}$ 的整數部分 $\to \lfloor \frac{n}{4} \rfloor$<br>case 餘三：$f ( 2, \frac{n}{2} ) \to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><p>$$f ( k, n ) =<br>\begin{cases}<br>n, &amp; \text{if $k$ is $1$} \<br>\begin{cases}<br>\frac{n}{2}, &amp; \text{if $n$ is even} \<br>\lfloor \frac{n}{4} \rfloor, &amp; \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \<br>f ( 2, \frac{n}{2} ), &amp; \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ }<br>\end{cases}, &amp; \text{if $k$ is $2$ }<br>\end{cases}<br>$$</p><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id="code"><a class="header-anchor" href="#code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 10005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span> <span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> ( n )&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">switch</span> ( n % <span class="number">4</span> )&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> n / <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> count ( n / <span class="number">2</span> );</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, m;</span><br><span class="line">    <span class="built_in">scanf</span> ( <span class="string">"%d%d"</span>, &amp;k, &amp;m );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, ( k == <span class="number">1</span> ? m : count ( m ) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="後記-2019-03-23-00-29"><a class="header-anchor" href="#後記-2019-03-23-00-29"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f ( k, n ) &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">n, &amp; \text&#123;if $k$ is $1$&#125; \\</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\frac&#123;n&#125;&#123;2&#125;, &amp; \text&#123;if $n$ is even&#125; \\</span><br><span class="line">\lfloor \frac&#123;n&#125;&#123;4&#125; \rfloor, &amp; \text&#123;if $n &#x3D; 4\times k + 1 ( k \in \mathbb&#123;R&#125; )$ &#125; \\</span><br><span class="line">f ( 2, \frac&#123;n&#125;&#123;2&#125; ), &amp; \text&#123;if $n &#x3D; 4\times k + 3 ( k \in \mathbb&#123;R&#125; )$ &#125;</span><br><span class="line">\end&#123;cases&#125;, &amp; \text&#123;if $k$ is $2$ &#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> TIOJ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
